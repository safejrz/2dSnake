<style>
    h1 {
        text-shadow: 10px 10px 0 rgba(0, 0, 0, 0);
        transition: all 0.9s;
    }

    html {
        margin: 20px;
    }

    .scoreLabel {
        font-weight: bolder;
        color: red;
        text-align: right;
    }

    .playarea {
        border: 1px solid black;
        background-color: lime;
    }

    .title {
        font-family: sans-serif;
        display: flex;
        color: black;

    }

    .instructions {
        font-style: italic;
    }
</style>
<meta charset="UTF-8">
<div class="title">
    <h1>RETRO SNAKE ‚ùó‚ùó‚ùó</h1>
</div>

<body>
    <label class="scoreLabel">Score:</label>
    <p></p>
    <canvas width="300" height="300" class="playarea">
    </canvas>
    <br />
    <br />
    <p class="instructions">
        Use the <b>ARROWS to MOVE</b> the snake to the food.<br />
        Use <b>SPACE to RESTART</b> the game.
    </p>
</body>

<script>
    const scale = 10;
    const emojiSize = 2;
    let xPadding = 0;
    let level = 0;
    let score = 0;
    let direction = [1, 0];
    let snake = [[6, 4], [5, 4], [4, 4]];
    let foodCoords = [];
    let foodEmoji;
    let refreshInterval = 250; // decreasing should increase speed

    const canvas = document.querySelector('.playarea');
    let ctx = canvas.getContext('2d');
    ctx.scale(scale, scale);
    const maxX = canvas.width / scale;
    const maxY = canvas.height / scale;

    let gameInterval;
    let titleInterval;

    function move(e) {
        switch (e.which) {
            case 32:
                restartGame();
                break;
            case 37: // ‚óÑ 17 / ‚Üê 27                
                if (direction[0] === 1 && direction[1] === 0) {
                    break;
                }
                console.log('‚óÑ');
                direction = [-1, 0];
                break;
            case 38: // ‚ñ≤ 30 / ‚Üë 24                
                if (direction[0] === 0 && direction[1] === 1) {
                    break;
                }
                console.log('‚ñ≤');
                direction = [0, -1];
                break;
            case 39: // ‚ñ∫ 16 / ‚Üí 26                
                if (direction[0] === -1 && direction[1] === 0) {
                    break;
                }
                console.log('‚ñ∫');
                direction = [1, 0];
                break;
            case 40: // ‚ñº 31 / ‚Üì 25                
                if (direction[0] === 0 && direction[1] === -1) {
                    break;
                }
                console.log('‚ñº');
                direction = [0, 1];
                break;
            default:
                break;
        }
    }

    function stopGame() {
        clearInterval(titleInterval);
        clearInterval(gameInterval);
    }

    function gameOver() {
        stopGame();
        displayGameOver();
        clearShadowTitle();
        xPadding = 1;
        let now = new Date();
        console.log(`Game Over :( ${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`);
    }

    function startGame() {        
        clearPlayArea();
        resumeGame();
    }

    function resumeGame() {
        let now = new Date();
        console.log(`Game started ${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`);
        displayScore();
        generateNextFood();
        titleInterval = setInterval(moveShadowTitle, 1000);
        gameInterval = setInterval(validateSnake, refreshInterval);
    }

    function restartGame() {
        stopGame();
        resetVariables();        
        startGame();
    }

    function resetVariables() {
        level = 0;
        score = 0;
        direction = [1, 0];
        snake = [[6, 4], [5, 4], [4, 4]];
        foodCoords = [];
        refreshInterval = 250; // decreasing value will increase speed
    }

    function validateSnake() {
        const nextX = snake[0][0] + direction[0];
        const nextY = snake[0][1] + direction[1];

        if (snake.find(([x, y]) => x == nextX && y == nextY) || //snake eating itself!
            ((nextX >= maxX || nextX <= -1) || (nextY >= maxY || nextY <= -1)) //snake out of play area!
        ) {
            return gameOver();
        }

        snake.unshift([nextX, nextY]); // add new element to the snake

        // Food behavior
        if (nextX == foodCoords[0] && nextY == foodCoords[1]
            || nextX == foodCoords[0] + 1 && nextY == foodCoords[1]
            || nextX == foodCoords[0] && nextY == foodCoords[1] + 1
            || nextX == foodCoords[0] + 1 && nextY == foodCoords[1] + 1
        ) {
            stopGame();
            level++;
            if(level < 15) {
            refreshInterval = Math.round(refreshInterval * 0.87);
            }
            resumeGame();            
        } else {
            snake.pop(); // dispose of the last element
        }

        //draw next game frame
        displaySnake();
        displayFood();
    }

    function displaySnake() {
        clearPlayArea();
        ctx.fillStyle = "black";
        snake.forEach(([x, y]) => { ctx.fillRect(x, y, 1, 1) });
    }

    function clearPlayArea() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function generateNextFood() {
        foodEmoji = getRandomFoodEmoji();
        console.log(foodEmoji);
        do {
            foodCoords = [Math.round(Math.random() * (maxX - emojiSize - xPadding)), Math.round(Math.random() * (maxY - emojiSize))];
        }
        while (snake.find(([x, y]) => x == foodCoords[0] && y == foodCoords[1]
            || x == foodCoords[0] + 1 && y == foodCoords[1]
            || x == foodCoords[0] && y == foodCoords[1] + 1
            || x == foodCoords[0] + 1 && y == foodCoords[1] + 1));

        displayFood();
    }

    function getRandomFoodEmoji() {
        const fruitNumber = Math.round(Math.random() * (44));
        switch (fruitNumber) {
            //fruits
            case 1:
                return "üçá";
            case 2:
                return "üçà";
            case 3:
                return "üçâ";
            case 4:
                return "üçä";
            case 5:
                return "üçã";
            case 6:
                return "üçå";
            case 7:
                return "üçç";
            case 8:
                return "ü•≠";
            case 9:
                return "üçé";
            case 10:
                return "üçè";
            case 11:
                return "üçê";
            case 12:
                return "üçë";
            case 13:
                return "üçí";
            case 14:
                return "üçì";
            case 15:
                return "ü•ù";
            case 16:
                return "üçÖ";
            case 17:
                return "ü••";
            //vegetables
            case 18:
                return "ü•ï";
            case 19:
                return "ü•î";
            case 20:
                return "ü•¶";
            case 21:
                return "üçÑ";
            //snacks
            case 22:
                return "üåÆ";
            case 23:
                return "ü•™";
            case 24:
                return "üåØ";
            case 25:
                return "üå≠";
            case 26:
                return "üçï";
            case 27:
                return "üçù";
            case 28:
                return "ü•°";
            case 29:
                return "ü•ü";
            //meat
            case 30:
                return "ü•©";
            case 31:
                return "ü•ì";
            case 32:
                return "üçó";
            case 33:
                //bread
                return "ü•®";
            case 34:
                return "üç©";
            case 35:
                return "üç™";
            case 36:
                return "üç∞";
            case 37:
                return "üßÅ";
            case 38:
                return "üç´";
            case 39:
                return "üç¶";
            //seafood
            case 40:
                return "üç§";
            case 41:
                return "ü¶ë";
            case 42:
                return "ü¶û";
            case 43:
                return "ü¶Ä";
            case 44:
                return "üç£";
            default:
                return "üí©";
        }
    }

    function moveShadowTitle() {
        const title = document.querySelector('.title');
        const text = title.querySelector('h1');
        const walk = 40;

        let now = new Date();
        let seconds = now.getSeconds();
        if (seconds > 30) {
            seconds = 30 - (seconds - 30);
        }

        let negativeSeconds = -1 * seconds;

        const { offsetWidth: width, offsetHeight: height } = title;
        const xWalk = Math.round((seconds / width * walk) + (walk / 20)); //- (walk / 2)
        const yWalk = Math.round((negativeSeconds / height * walk) + (walk / 10)); //- (walk / 2)
        const xNWalk = -1.2 * Math.round((seconds / width * walk) - (walk / 10));
        const yNWalk = -1 * Math.round((negativeSeconds / height * walk) - (walk / 20));

        text.style.textShadow = `
      ${xWalk}px ${yWalk}px 0 rgba(255, 255, 0, .7),
      ${yWalk}px ${xWalk}px 0 rgba(0, 255, 0, .7),
      ${yNWalk}px ${xNWalk}px 0 rgba(0, 255, 255, .7),
      ${xNWalk}px ${Math.round(yNWalk / 2)}px 0 rgba(255, 0, 255, .7)
      `;
    }

    function clearShadowTitle() {
        const title = document.querySelector('.title');
        const text = title.querySelector('h1');
        text.style.textShadow = "10px 10px 0 rgba(0, 0, 0, 0)";
    }

    function displayScore() {
        const scoreText = document.querySelector('.scoreLabel');        
        if (level <= 1) {
            score = level * 100;
        } else {
            score = Math.round(score * 1.1 + 100);
        }

        scoreText.innerText = `Score:${score}`;
    }

    function displayFood() {
        ctx.font = `${emojiSize}px Arial`;
        ctx.textBaseline = "middle";
        //displayWhiteRectangle(); // uncomment to debbug for padding errors.
        ctx.fillText(foodEmoji, foodCoords[0] + xPadding, foodCoords[1] + 1, emojiSize);
    }

    function displayWhiteRectangle() {
        ctx.fillStyle = "rgb(255, 255, 255)";
        ctx.fillRect(foodCoords[0], foodCoords[1], emojiSize, emojiSize)
    }

    function displayGameOver() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = "4px Arial Black";
        ctx.fillStyle = "rgb(255, 0, 0)";
        ctx.textAlign = "center";
        ctx.fillText("Game Over!", Math.round(maxX / 2), Math.round(maxY / 2));
    }

    document.addEventListener("keydown", move);
    startGame();
</script>